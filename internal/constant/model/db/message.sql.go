// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: message.sql

package db

import (
	"context"

	"github.com/shopspring/decimal"
)

const addMessage = `-- name: AddMessage :one
INSERT INTO messages
    (sender_phone, content, price, receiver_phone, type,status)
    VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, sender_phone, content, price, receiver_phone, type, status, delivery_status, message_id, created_at
`

type AddMessageParams struct {
	SenderPhone   string          `json:"sender_phone"`
	Content       string          `json:"content"`
	Price         decimal.Decimal `json:"price"`
	ReceiverPhone string          `json:"receiver_phone"`
	Type          MessageType     `json:"type"`
	Status        string          `json:"status"`
}

func (q *Queries) AddMessage(ctx context.Context, arg AddMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, addMessage,
		arg.SenderPhone,
		arg.Content,
		arg.Price,
		arg.ReceiverPhone,
		arg.Type,
		arg.Status,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.SenderPhone,
		&i.Content,
		&i.Price,
		&i.ReceiverPhone,
		&i.Type,
		&i.Status,
		&i.DeliveryStatus,
		&i.MessageID,
		&i.CreatedAt,
	)
	return i, err
}

const getMessageWithPrefix = `-- name: GetMessageWithPrefix :many
SELECT id, sender_phone, content, price, receiver_phone, type, status, delivery_status, message_id, created_at FROM messages
    WHERE content LIKE $2 AND receiver_phone=$1
    LIMIT $3
    OFFSET $4
`

type GetMessageWithPrefixParams struct {
	ReceiverPhone string `json:"receiver_phone"`
	Content       string `json:"content"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

func (q *Queries) GetMessageWithPrefix(ctx context.Context, arg GetMessageWithPrefixParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getMessageWithPrefix,
		arg.ReceiverPhone,
		arg.Content,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SenderPhone,
			&i.Content,
			&i.Price,
			&i.ReceiverPhone,
			&i.Type,
			&i.Status,
			&i.DeliveryStatus,
			&i.MessageID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesBySender = `-- name: GetMessagesBySender :many
SELECT id, sender_phone, content, price, receiver_phone, type, status, delivery_status, message_id, created_at FROM messages
WHERE sender_phone=$1
LIMIT $2
    OFFSET $3
`

type GetMessagesBySenderParams struct {
	SenderPhone string `json:"sender_phone"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) GetMessagesBySender(ctx context.Context, arg GetMessagesBySenderParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getMessagesBySender, arg.SenderPhone, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SenderPhone,
			&i.Content,
			&i.Price,
			&i.ReceiverPhone,
			&i.Type,
			&i.Status,
			&i.DeliveryStatus,
			&i.MessageID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllMessages = `-- name: ListAllMessages :many
SELECT id, sender_phone, content, price, receiver_phone, type, status, delivery_status, message_id, created_at FROM messages
        LIMIT $1
OFFSET $2
`

type ListAllMessagesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllMessages(ctx context.Context, arg ListAllMessagesParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listAllMessages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SenderPhone,
			&i.Content,
			&i.Price,
			&i.ReceiverPhone,
			&i.Type,
			&i.Status,
			&i.DeliveryStatus,
			&i.MessageID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeliveryStatus = `-- name: UpdateDeliveryStatus :exec
UPDATE messages
SET delivery_status = $2
WHERE message_id = $1
`

type UpdateDeliveryStatusParams struct {
	MessageID      string `json:"message_id"`
	DeliveryStatus string `json:"delivery_status"`
}

func (q *Queries) UpdateDeliveryStatus(ctx context.Context, arg UpdateDeliveryStatusParams) error {
	_, err := q.db.Exec(ctx, updateDeliveryStatus, arg.MessageID, arg.DeliveryStatus)
	return err
}
