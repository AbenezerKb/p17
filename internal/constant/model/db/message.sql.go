// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: message.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const addMessage = `-- name: AddMessage :one
INSERT INTO public.messages
    (sender_phone, content, price, receiver_phone, type,status)
    VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, client_id, sender_phone, content, price, receiver_phone, type, status, delivery_status, created_at
`

type AddMessageParams struct {
	SenderPhone   string          `json:"sender_phone"`
	Content       string          `json:"content"`
	Price         decimal.Decimal `json:"price"`
	ReceiverPhone string          `json:"receiver_phone"`
	Type          MessageType     `json:"type"`
	Status        string          `json:"status"`
}

func (q *Queries) AddMessage(ctx context.Context, arg AddMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, addMessage,
		arg.SenderPhone,
		arg.Content,
		arg.Price,
		arg.ReceiverPhone,
		arg.Type,
		arg.Status,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.SenderPhone,
		&i.Content,
		&i.Price,
		&i.ReceiverPhone,
		&i.Type,
		&i.Status,
		&i.DeliveryStatus,
		&i.CreatedAt,
	)
	return i, err
}

const getMessageWithPrefix = `-- name: GetMessageWithPrefix :many
SELECT id, client_id, sender_phone, content, price, receiver_phone, type, status, delivery_status, created_at FROM public.messages
    WHERE content LIKE $2 AND receiver_phone=$1
    LIMIT $3
    OFFSET $4
`

type GetMessageWithPrefixParams struct {
	ReceiverPhone string `json:"receiver_phone"`
	Content       string `json:"content"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

func (q *Queries) GetMessageWithPrefix(ctx context.Context, arg GetMessageWithPrefixParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getMessageWithPrefix,
		arg.ReceiverPhone,
		arg.Content,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.SenderPhone,
			&i.Content,
			&i.Price,
			&i.ReceiverPhone,
			&i.Type,
			&i.Status,
			&i.DeliveryStatus,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesBySender = `-- name: GetMessagesBySender :many
SELECT id, client_id, sender_phone, content, price, receiver_phone, type, status, delivery_status, created_at FROM public.messages
WHERE sender_phone=$1
LIMIT $2
    OFFSET $3
`

type GetMessagesBySenderParams struct {
	SenderPhone string `json:"sender_phone"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) GetMessagesBySender(ctx context.Context, arg GetMessagesBySenderParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getMessagesBySender, arg.SenderPhone, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.SenderPhone,
			&i.Content,
			&i.Price,
			&i.ReceiverPhone,
			&i.Type,
			&i.Status,
			&i.DeliveryStatus,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lastMonthMessagePriceAndCount = `-- name: LastMonthMessagePriceAndCount :many
SELECT  price, COUNT(id) as COUNT,
        SUM (price) AS sum
FROM public.messages
WHERE client_id=$1 AND "created_at" BETWEEN NOW() - INTERVAL '1 MONTH' AND NOW()
GROUP BY  price
`

type LastMonthMessagePriceAndCountRow struct {
	Price decimal.Decimal `json:"price"`
	Count int64           `json:"count"`
	Sum   int64           `json:"sum"`
}

func (q *Queries) LastMonthMessagePriceAndCount(ctx context.Context, clientID string) ([]LastMonthMessagePriceAndCountRow, error) {
	rows, err := q.db.Query(ctx, lastMonthMessagePriceAndCount, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LastMonthMessagePriceAndCountRow{}
	for rows.Next() {
		var i LastMonthMessagePriceAndCountRow
		if err := rows.Scan(&i.Price, &i.Count, &i.Sum); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllMessages = `-- name: ListAllMessages :many
SELECT id, client_id, sender_phone, content, price, receiver_phone, type, status, delivery_status, created_at FROM public.messages
        LIMIT $1
OFFSET $2
`

type ListAllMessagesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllMessages(ctx context.Context, arg ListAllMessagesParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listAllMessages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.SenderPhone,
			&i.Content,
			&i.Price,
			&i.ReceiverPhone,
			&i.Type,
			&i.Status,
			&i.DeliveryStatus,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeliveryStatus = `-- name: UpdateDeliveryStatus :exec
UPDATE public.messages
SET delivery_status = $2
WHERE id = $1
`

type UpdateDeliveryStatusParams struct {
	ID             uuid.UUID `json:"id"`
	DeliveryStatus string    `json:"delivery_status"`
}

func (q *Queries) UpdateDeliveryStatus(ctx context.Context, arg UpdateDeliveryStatusParams) error {
	_, err := q.db.Exec(ctx, updateDeliveryStatus, arg.ID, arg.DeliveryStatus)
	return err
}
